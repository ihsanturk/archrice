#!/usr/local/bin/python3

import curses
import random
import time
import os

def center(message, length):
    return (int(length / 2) - int(len(message) / 2))


class Board:
    sizeRow = 4
    sizeCol = 4
    emptyChar = 0

    table = []

    def __init__(self, r, c, e):
        self.sizeRow = r
        self.sizeCol = c
        self.empyChar = e

    def maximum(self):
        maxValue = 0
        for row in self.table:
            for val in row:
                if val > maxValue:
                    maxvalue = val
        return maxValue

    def up(self, r, c):
        if r > 0:
            return self.table[r - 1][c]
        else:
            return None
    def left(self, r, c):
        if c > 0:
            return self.table[r][c - 1]
        else:
            return None
    def down(self, r, c):
        if r < self.sizeRow - 1:
            return self.table[r + 1][c]
        else:
            return None
    def right(self, r, c):
        if c < self.sizeCol - 1:
            return self.table[r][c + 1]
        else:
            return None

    
class Game2048:
    score = 0
    isWon = False
    isFail = False
    destination = 2048
    board = Board(0, 0, 0)

    def __init__(self, row, col):
        self.board = Board(row, col, 0)


    def findEmptyCells(self):
        emptyCells = []
        for r in range(0, self.board.sizeRow):
            for c in range(0, self.board.sizeCol):
                if self.board.table[r][c] == self.board.emptyChar:
                    emptyCells.append([r, c])
        return emptyCells


    def combineCells(self, d):
        b = self.board
        if d == 'UP':
            for r in range(1, b.sizeRow):
                for c in range(0, b.sizeCol):
                    if b.table[r][c] != b.emptyChar and b.table[r][c] == b.up(r, c):
                        b.table[r - 1][c] += b.table[r][c]
                        b.table[r][c] = b.emptyChar
        if d == 'LEFT':
            for r in range(0, b.sizeRow):
                for c in range(1, b.sizeCol):
                    if b.table[r][c] != b.emptyChar and b.table[r][c] == b.left(r, c):
                        b.table[r][c - 1] += b.table[r][c]
                        b.table[r][c] = b.emptyChar
        if d == 'DOWN':
            for r in reversed(range(0, b.sizeRow - 1)):
                for c in range(0, b.sizeCol):
                    if b.table[r][c] != b.emptyChar and b.table[r][c] == b.down(r, c):
                        b.table[r + 1][c] += b.table[r][c]
                        b.table[r][c] = b.emptyChar
        if d == 'RIGHT':
            for r in range(0, b.sizeRow):
                for c in reversed(range(0, b.sizeCol - 1)):
                    if b.table[r][c] != b.emptyChar and b.table[r][c] == b.right(r, c):
                        b.table[r][c + 1] += b.table[r][c]
                        b.table[r][c] = b.emptyChar
        

    def moveCell(self, cr, cc, d, isMoved): #currentRow, currentColumn, direction
        b = self.board

        nr = cr
        nc = cc

        if d == 'UP':
            nr -= 1 
            if b.table[cr][cc] != b.emptyChar:
                if b.up(cr, cc) == b.emptyChar:
                    b.table[nr][nc] = b.table[cr][cc]
                    b.table[cr][cc] = b.emptyChar
                    isMoved = True
                    self.moveCell(nr, nc, d, isMoved)
        elif d == 'LEFT':
            nc -= 1
            if b.table[cr][cc] != b.emptyChar:
                if b.left(cr, cc) == b.emptyChar:
                    b.table[nr][nc] = b.table[cr][cc]
                    b.table[cr][cc] = b.emptyChar
                    isMoved = True
                    self.moveCell(nr, nc, d, isMoved)
        elif d == 'DOWN':
            nr += 1
            if b.table[cr][cc] != b.emptyChar:
                if b.down(cr, cc) == b.emptyChar:
                    b.table[nr][nc] = b.table[cr][cc]
                    b.table[cr][cc] = b.emptyChar
                    isMoved = True
                    self.moveCell(nr, nc, d, isMoved)
        elif d == 'RIGHT':
            nc += 1
            if b.table[cr][cc] != b.emptyChar:
                if b.right(cr, cc) == b.emptyChar:
                    b.table[nr][nc] = b.table[cr][cc]
                    b.table[cr][cc] = b.emptyChar
                    isMoved = True
                    self.moveCell(nr, nc, d, isMoved)
        else:
            isMoved = False

        return isMoved


    # Example Scenario
    #                    Push to edge     Combine
    #   [ ][ ][ ][ ]  >  [ ][2][ ][ ]  >  [ ][4][ ][ ]
    #   [ ][2][ ][ ]  >  [ ][2][ ][ ]  >  [ ][ ][ ][ ]
    #   [ ][2][ ][ ]  >  [ ][ ][ ][ ]  >  [ ][ ][ ][ ]
    #   [ ][ ][ ][ ]  >  [ ][ ][ ][ ]  >  [ ][ ][ ][ ]


    def moveBoard(self, d):
        isMoved = False
        if d == 'UP':
            for r in range(1, self.board.sizeRow):
                for c in range(0, self.board.sizeCol):
                    isMoved = self.moveCell(r, c, d, isMoved)
        if d == 'LEFT':
            for r in range(0, self.board.sizeRow):
                for c in range(1, self.board.sizeCol):
                    isMoved = self.moveCell(r, c, d, isMoved)
        if d == 'DOWN':
            for r in reversed(range(0, self.board.sizeRow)):
                for c in range(0, self.board.sizeCol):
                    isMoved = self.moveCell(r, c, d, isMoved)
        if d == 'RIGHT':
            for r in range(0, self.board.sizeRow):
                for c in reversed(range(0, self.board.sizeCol)):
                    isMoved = self.moveCell(r, c, d, isMoved)
        return isMoved


    def appendNewCell(self):
        emptyCells = self.findEmptyCells()
        if len(emptyCells) == 0:
            isFail = True
            print(f"Game Over! Score: {self.score}")
        else:
            choice = random.choice(emptyCells)
            choiceRow = choice[0]
            choiceCol = choice[1]

            self.board.table[choiceRow][choiceCol] = random.choice([2, 4])

    def scroll(self, direction):
        isBoardMoved = self.moveBoard(direction)
        self.combineCells(direction)

        if isBoardMoved == True:
            self.appendNewCell()
                        
    def displayGame(self):
        for row in self.board.table:
            for col in row:
                if col == self.board.emptyChar:
                    print(".", end = "")
                    print(" ", end = "")
                else:
                    print(col, end = " ")
            print()
        
    def startBoard(self):
        initRandomValue = random.choice([2, 4])
        initRow = random.randint(0, self.board.sizeRow - 1)
        initCol = random.randint(0, self.board.sizeCol - 1)
        for r in range(self.board.sizeRow):
            self.board.table.append(list())
            for c in range(self.board.sizeCol):
                if r == initRow and c == initCol:
                    self.board.table[r].append(initRandomValue)
                else:
                    self.board.table[r].append(self.board.emptyChar)
        self.displayGame()

    def startGame(self):
        ans = "0"
        while ans != "q":
            os.system('clear')
            self.displayGame()
            print("\nMax: ", self.board.maximum())
            ans = input("Move: ")

            if ans == "w":
                self.scroll("UP")
            elif ans == "a":
                self.scroll("LEFT")
            elif ans == "s":
                self.scroll("DOWN")
            elif ans == "d":
                self.scroll("RIGHT")
    
    def createNewGame(self):
        self.startBoard()
        self.startGame()


if __name__ == '__main__':
    app = Game2048(4, 4)
    app.createNewGame()
